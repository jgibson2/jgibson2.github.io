<!DOCTYPE html>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<link rel="stylesheet" href="ar-pdb.css">
<!-- three.js library -->
<script src='js/three/three.min.js'></script>
<script src='js/three/loaders/PDBLoader.js'></script>
<!-- ar.js -->
<script src="js/ar.min.js"></script>
<script src="js/jquery-1.7.min.js"></script>
<script>THREEx.ArToolkitContext.baseURL = 'js/'</script>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>

<div id="myNav" class="overlay">

    <!-- Button to close the overlay navigation -->
    <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>

    <!-- Overlay content -->
    <div class="overlay-content">
        <p>Protein: <input type="text" id="pdb_id" value="pdb:4N77"></p>

        <p>Scale: <input type="number" id="scale" value="2.0" step=0.01></p>

        <p>Amino Acid Scale: <input type="number" id="aaScale" value="0.025" step=0.001></p>

        <p>Representation:
        <select id="representation">
            <option value="cartoon">Cartoon</option>
            <option value="sphere">Sphere</option>
            <option value="mainchain">Main Chain</option>
        </select></p>

        <p>
            <br>
            To use, open <a href="https://jeromeetienne.github.io/AR.js/data/images/HIRO.jpg">this marker</a> on another device (or print it out)
        and point the camera at the marker.</p>

        <p>
            <br>
            Use the above boxes to change the scale of the model, the scales of the amino acids / atoms, and the PDB shown. Any PDB on RSCB can be shown
            by entering "pdb:[PDB CODE HERE]" into the Protein box.
        </p>
    </div>

</div>

<!-- Use any element to open/show the overlay navigation menu -->
<span onclick="openNav()" style='z-index: 99; position: absolute; display: block; font-size: 300%'>Menu</span>

<div style='position: absolute; top: 10px; width:100%; text-align: center; z-index: 1;'>
    AR Protein Visualizer: Inspired by GLmol and AR.js
    John Gibson
</div>
<script>
    /* Open when someone clicks on the span element */

    //////////////////////////////////////////////////////////////////////////////////
    //		Init
    //////////////////////////////////////////////////////////////////////////////////

    // init renderer
    var renderer	= new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
    });
    renderer.setClearColor(new THREE.Color('lightgrey'), 0)
    renderer.setSize( 640, 480 );
    renderer.domElement.style.position = 'absolute'
    renderer.domElement.style.top = '0px'
    renderer.domElement.style.left = '0px'
    document.body.appendChild( renderer.domElement );

    // array of functions for the rendering loop
    var onRenderFcts= [];

    // init scene and camera
    var scene	= new THREE.Scene();

    //////////////////////////////////////////////////////////////////////////////////
    //		Initialize a basic camera
    //////////////////////////////////////////////////////////////////////////////////

    // Create a camera
    var camera = new THREE.Camera();
    scene.add(camera);

    ////////////////////////////////////////////////////////////////////////////////
    //          handle arToolkitSource
    ////////////////////////////////////////////////////////////////////////////////

    var arToolkitSource = new THREEx.ArToolkitSource({
        // to read from the webcam
        sourceType : 'webcam',

        // // to read from an image
        // sourceType : 'image',
        // sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/images/img.jpg',

        // to read from a video
        // sourceType : 'video',
        // sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/videos/headtracking.mp4',
    })

    arToolkitSource.init(function onReady(){
        onResize()
    })

    // handle resize
    window.addEventListener('resize', function(){
        onResize()
    })
    function onResize(){
        arToolkitSource.onResizeElement()
        arToolkitSource.copyElementSizeTo(renderer.domElement)
        if( arToolkitContext.arController !== null ){
            arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas)
        }
    }
    ////////////////////////////////////////////////////////////////////////////////
    //          initialize arToolkitContext
    ////////////////////////////////////////////////////////////////////////////////


    // create atToolkitContext
    var arToolkitContext = new THREEx.ArToolkitContext({
        cameraParametersUrl: THREEx.ArToolkitContext.baseURL + '../data/data/camera_para.dat',
        detectionMode: 'mono',
    })
    // initialize it
    arToolkitContext.init(function onCompleted(){
        // copy projection matrix to camera
        camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
    })

    // update artoolkit on every frame
    onRenderFcts.push(function(){
        if( arToolkitSource.ready === false )	return

        arToolkitContext.update( arToolkitSource.domElement )

        // update scene.visible if the marker is seen
        scene.visible = camera.visible
    });

    ////////////////////////////////////////////////////////////////////////////////
    //          Create a ArMarkerControls
    ////////////////////////////////////////////////////////////////////////////////

    // init controls for camera
    var markerControls = new THREEx.ArMarkerControls(arToolkitContext, camera, {
        type : 'pattern',
        patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.hiro',
        // patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.kanji',
        // as we controls the camera, set changeMatrixMode: 'cameraTransformMatrix'
        changeMatrixMode: 'cameraTransformMatrix'
    })
    // as we do changeMatrixMode: 'cameraTransformMatrix', start with invisible scene
    scene.visible = false;


    function clearThree(obj){
        scene = new THREE.Scene();
        scene.add(camera);
        onRenderFcts = [];
        onRenderFcts.push(function(){
            if( arToolkitSource.ready === false )	return

            arToolkitContext.update( arToolkitSource.domElement )

            // update scene.visible if the marker is seen
            scene.visible = camera.visible
        });
        onRenderFcts.push(function(){
            renderer.render( scene, camera );
        });
    }

    function openNav() {
        document.getElementById("myNav").style.width = "100%";
    }

    /* Close when someone clicks on the "x" symbol inside the overlay */
    function closeNav() {
        document.getElementById("myNav").style.width = "0%";
        clearThree(scene);
        makeScene(document.getElementById("pdb_id").value,
            {scale: document.getElementById("scale").value,
            aaScale: document.getElementById("aaScale").value,
            representation: document.getElementById("representation").value});
    }

    //////////////////////////////////////////////////////////////////////////////////
    //		add an object in the scene
    //////////////////////////////////////////////////////////////////////////////////



    function makeScene(id, params) {
        // instantiate a loader
        var loader = new PDBLoader(id.substr(4), scene, params);

        function download(query) {
            var baseURL = '';
            if (query.substr(0, 4) == 'pdb:') {
                query = query.substr(4).toUpperCase();
                if (!query.match(/^[1-9][A-Za-z0-9]{3}$/)) {
                    alert("Wrong PDB ID"); return;
                }
                // uri = "https://www.pdb.org/pdb/files/" + query + ".pdb";
                uri = "https://files.rcsb.org/download/" + query + ".pdb";
            } else if (query.substr(0, 4) == 'cid:') {
                query = query.substr(4);
                if (!query.match(/^[1-9]+$/)) {
                    alert("Wrong Compound ID"); return;
                }
                uri = "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + query +
                    "/SDF?record_type=3d";
            }
            $.get(uri, function(ret) {
                console.log("URI: " + uri);
                loader.loadMolecule(ret);
            });
        }

        download(id);
    }

    makeScene('pdb:1BBY', {});

    //////////////////////////////////////////////////////////////////////////////////
    //		render the whole thing on the page
    //////////////////////////////////////////////////////////////////////////////////

    // render the scene
    onRenderFcts.push(function(){
        renderer.render( scene, camera );
    });

    // run the rendering loop
    var lastTimeMsec = null;
    requestAnimationFrame(function animate(nowMsec){
        // keep looping
        requestAnimationFrame( animate );
        // measure time
        lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
        var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
        lastTimeMsec	= nowMsec
        // call each update function
        onRenderFcts.forEach(function(onRenderFct){
            onRenderFct(deltaMsec/1000, nowMsec/1000)
        })
    })
</script></body>
